{% extends "base.html" %}

{% block title %}{{ title }} - CivitAI Models{% endblock %}

{% block page_styles %}
<!-- gallery.css -->
<style>
    {{ read_file('css/gallery.css') }}
</style>
{% endblock %}

{% block header %}{{ title }}{% endblock %}

{% block content %}
<div class="gallery-container">
    {% if models %}
    <div class="gallery-controls">
        <div class="search-container">
            <input type="text" id="gallery-search" placeholder="Search models...">
            <button id="clear-search" title="Clear search">Ã—</button>
        </div>
        
        <div class="view-toggle">
            <button id="grid-view" class="view-button active" title="Grid view">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
            </button>
            <button id="list-view" class="view-button" title="List view">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
            </button>
        </div>
        
        <div class="sort-controls">
            <select id="sort-by" title="Sort by">
                <option value="name">Name</option>
                <option value="created_at">Date Created</option>
                <option value="updated_at">Date Updated</option>
                <option value="downloads">Downloads</option>
                <option value="rating">Rating</option>
            </select>
            <button id="sort-direction" data-direction="desc" title="Sort direction">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l6 6 6-6"/></svg>
            </button>
        </div>
    </div>
    
    <div id="no-results" class="no-results" style="display: none;">
        <p>No matching models found. Try adjusting your search.</p>
    </div>
    
    <div class="models-grid view-active">
        {% for model in models %}
            {% include "components/model_card.html" %}
        {% endfor %}
    </div>
    
    <div class="models-list">
        {% for model in models %}
            {% include "components/model_list_item.html" %}
        {% endfor %}
    </div>
    
    {% else %}
    <div class="empty-gallery">
        <p>No models found.</p>
    </div>
    {% endif %}
</div>

<!-- Inline script for gallery functionality -->
<script>
// Immediately executing function for gallery functionality
(function() {
  console.log("Gallery functionality script running");
  
  // DOM Elements
  const gridViewBtn = document.getElementById('grid-view');
  const listViewBtn = document.getElementById('list-view');
  const modelsGrid = document.querySelector('.models-grid');
  const modelsList = document.querySelector('.models-list');
  const searchInput = document.getElementById('gallery-search');
  const clearSearchBtn = document.getElementById('clear-search');
  const sortBySelect = document.getElementById('sort-by');
  const sortDirectionBtn = document.getElementById('sort-direction');
  const noResultsEl = document.getElementById('no-results');
  const modelCards = document.querySelectorAll('.model-card');
  const modelListItems = document.querySelectorAll('.model-list-item');
  
  console.log("Gallery elements found:", {
    gridViewBtn, listViewBtn, modelsGrid, modelsList,
    searchInput, clearSearchBtn, sortBySelect, sortDirectionBtn,
    modelCards: modelCards.length, modelListItems: modelListItems.length
  });
  
  // Helper for localStorage
  function storePreference(key, value) {
    try {
      localStorage.setItem('gallery_' + key, value);
    } catch (e) {
      console.warn('localStorage not available:', e);
    }
  }
  
  function getPreference(key, defaultValue) {
    try {
      const value = localStorage.getItem('gallery_' + key);
      return value !== null ? value : defaultValue;
    } catch (e) {
      console.warn('localStorage not available:', e);
      return defaultValue;
    }
  }
  
  // 1. View Toggle Functionality
  if (gridViewBtn && listViewBtn) {
    function setViewMode(mode) {
      console.log(`Setting view mode to: ${mode}`);
      if (mode === 'grid') {
        modelsGrid.classList.add('view-active');
        modelsList.classList.remove('view-active');
        gridViewBtn.classList.add('active');
        listViewBtn.classList.remove('active');
      } else {
        modelsList.classList.add('view-active');
        modelsGrid.classList.remove('view-active');
        listViewBtn.classList.add('active');
        gridViewBtn.classList.remove('active');
      }
      storePreference('view', mode);
    }
    
    gridViewBtn.addEventListener('click', function() {
      setViewMode('grid');
    });
    
    listViewBtn.addEventListener('click', function() {
      setViewMode('list');
    });
    
    // Load saved view preference
    const savedView = getPreference('view', 'grid');
    if (savedView === 'list') {
      setViewMode('list');
    }
    
    console.log("View toggle event listeners attached");
  } else {
    console.error("View toggle buttons not found");
  }
  
  // 2. Sorting Functionality
  if (sortBySelect && sortDirectionBtn) {
    function sortModels(sortBy, direction) {
      console.log(`Sorting by: ${sortBy}, direction: ${direction}`);
      
      // Store preferences
      storePreference('sortBy', sortBy);
      storePreference('sortDir', direction);
      
      const multiplier = direction === 'asc' ? 1 : -1;
      
      // Sort function for different data types
      function compareValues(a, b) {
        let valueA, valueB;
        
        if (sortBy === 'name') {
          valueA = a.dataset.name || '';
          valueB = b.dataset.name || '';
          return multiplier * valueA.localeCompare(valueB);
        } 
        else if (sortBy === 'rating') {
          valueA = parseFloat(a.dataset.rating) || 0;
          valueB = parseFloat(b.dataset.rating) || 0;
        } 
        else if (sortBy === 'downloads') {
          valueA = parseInt(a.dataset.downloads) || 0;
          valueB = parseInt(b.dataset.downloads) || 0;
        }
        else if (sortBy === 'created_at' || sortBy === 'updated_at') {
          // Parse dates and handle empty values
          valueA = a.dataset[sortBy] ? new Date(a.dataset[sortBy]).getTime() : 0;
          valueB = b.dataset[sortBy] ? new Date(b.dataset[sortBy]).getTime() : 0;
        }
        
        // For numeric values
        if (valueA === valueB) {
          // Secondary sort by name if values are equal
          return multiplier * (a.dataset.name || '').localeCompare(b.dataset.name || '');
        }
        return multiplier * (valueA - valueB);
      }
      
      // Convert collections to arrays for sorting
      const gridItems = Array.from(modelCards);
      const listItems = Array.from(modelListItems);
      
      // Sort grid items
      gridItems.sort(compareValues);
      gridItems.forEach(item => modelsGrid.appendChild(item));
      
      // Sort list items
      listItems.sort(compareValues);
      listItems.forEach(item => modelsList.appendChild(item));
      
      console.log(`Sorted ${gridItems.length} grid items and ${listItems.length} list items`);
    }
    
    // Load saved sort preferences
    const savedSortBy = getPreference('sortBy', 'name');
    const savedSortDir = getPreference('sortDir', 'desc');
    
    // Initialize with saved preferences
    sortBySelect.value = savedSortBy;
    sortDirectionBtn.setAttribute('data-direction', savedSortDir);
    if (savedSortDir === 'asc') {
      sortDirectionBtn.querySelector('svg').style.transform = 'rotate(180deg)';
    }
    
    // Apply initial sorting
    sortModels(savedSortBy, savedSortDir);
    
    // Add event listeners
    sortBySelect.addEventListener('change', function() {
      console.log("Sort by changed:", this.value);
      const sortBy = this.value;
      const direction = sortDirectionBtn.getAttribute('data-direction');
      sortModels(sortBy, direction);
    });
    
    sortDirectionBtn.addEventListener('click', function() {
      const currentDirection = this.getAttribute('data-direction');
      const newDirection = currentDirection === 'desc' ? 'asc' : 'desc';
      
      console.log("Sort direction changed:", newDirection);
      
      this.setAttribute('data-direction', newDirection);
      
      // Toggle the arrow direction
      if (newDirection === 'asc') {
        this.querySelector('svg').style.transform = 'rotate(180deg)';
      } else {
        this.querySelector('svg').style.transform = '';
      }
      
      sortModels(sortBySelect.value, newDirection);
    });
    
    console.log("Sort functionality event listeners attached");
  } else {
    console.error("Sort controls not found");
  }
  
  // 3. Search Functionality
  if (searchInput && clearSearchBtn) {
    let debounceTimeout;
    
    function debounce(fn, delay) {
      return function(...args) {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }
    
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    function highlightText(element, searchText) {
      if (!searchText.trim()) return;
      
      const allTextNodes = [];
      const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        { acceptNode: node => node.nodeValue.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT },
        false
      );
      
      let node;
      while (node = walker.nextNode()) {
        allTextNodes.push(node);
      }
      
      const regex = new RegExp(`(${escapeRegExp(searchText)})`, 'gi');
      allTextNodes.forEach(textNode => {
        const parent = textNode.parentNode;
        if (parent.nodeName === 'SCRIPT' || parent.closest('.highlight')) return;
        
        const matches = textNode.nodeValue.match(regex);
        if (!matches) return;
        
        const fragment = document.createDocumentFragment();
        const parts = textNode.nodeValue.split(regex);
        
        parts.forEach((part, i) => {
          if (i % 2 === 0) {
            // Regular text
            fragment.appendChild(document.createTextNode(part));
          } else {
            // Matched text to highlight
            const highlightSpan = document.createElement('span');
            highlightSpan.className = 'highlight';
            highlightSpan.appendChild(document.createTextNode(part));
            fragment.appendChild(highlightSpan);
          }
        });
        
        parent.replaceChild(fragment, textNode);
      });
    }
    
    function removeHighlights(element) {
      const highlights = element.querySelectorAll('.highlight');
      highlights.forEach(highlight => {
        const parent = highlight.parentNode;
        const textNode = document.createTextNode(highlight.textContent);
        parent.replaceChild(textNode, highlight);
        parent.normalize(); // Combine adjacent text nodes
      });
    }
    
    function searchModels(searchText) {
      console.log("Searching for:", searchText);
      
      searchText = searchText.trim().toLowerCase();
      let matchCount = 0;
      
      // Process all model cards
      modelCards.forEach(card => {
        removeHighlights(card);
        
        const name = card.dataset.name || '';
        const type = card.dataset.type || '';
        const baseModel = card.dataset.baseModel || '';
        const description = card.dataset.description || '';
        
        const isMatch = !searchText || 
          name.includes(searchText) || 
          type.includes(searchText) || 
          baseModel.includes(searchText) || 
          description.includes(searchText);
        
        card.style.display = isMatch ? '' : 'none';
        
        if (isMatch) {
          matchCount++;
          highlightText(card, searchText);
        }
      });
      
      // Process all model list items
      modelListItems.forEach(item => {
        removeHighlights(item);
        
        const name = item.dataset.name || '';
        const type = item.dataset.type || '';
        const baseModel = item.dataset.baseModel || '';
        const description = item.dataset.description || '';
        
        const isMatch = !searchText || 
          name.includes(searchText) || 
          type.includes(searchText) || 
          baseModel.includes(searchText) || 
          description.includes(searchText);
        
        item.style.display = isMatch ? '' : 'none';
        
        if (isMatch) {
          highlightText(item, searchText);
        }
      });
      
      // Show/hide no results message
      noResultsEl.style.display = matchCount === 0 ? 'block' : 'none';
      
      console.log(`Search found ${matchCount} matches`);
      return matchCount;
    }
    
    const debouncedSearch = debounce(searchModels, 300);
    
    searchInput.addEventListener('input', function() {
      debouncedSearch(this.value);
    });
    
    clearSearchBtn.addEventListener('click', function() {
      searchInput.value = '';
      searchModels('');
      searchInput.focus();
    });
    
    console.log("Search functionality event listeners attached");
  } else {
    console.error("Search controls not found");
  }
  
  // 4. Format Dates
  function formatDates() {
    document.querySelectorAll('.date-value').forEach(dateEl => {
      const dateStr = dateEl.textContent;
      if (!dateStr) return;
      
      try {
        const date = new Date(dateStr);
        if (isNaN(date.getTime())) return;
        
        // Format: YYYY-MM-DD
        const formatted = date.toISOString().split('T')[0];
        dateEl.textContent = formatted;
      } catch (e) {
        console.warn('Error formatting date:', e);
      }
    });
    console.log("Date formatting applied");
  }
  
  formatDates();
  
  console.log("Gallery script initialization complete");
})();
</script>
{% endblock %}

{% block page_scripts %}
<!-- Any additional scripts can go here -->
{% endblock %}
